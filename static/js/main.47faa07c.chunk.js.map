{"version":3,"sources":["p2p.js","utils.js","cards.js","config.js","assert.js","logic.js","Chat.js","Game.js","App.js","reportWebVitals.js","index.js"],"names":["RTC_CONFIG","iceServers","urls","onOpen","conn","console","log","messageHandlers","data","type","value","indx","onMessage","e","JSON","parse","addMessageHandler","handler","messageHandlersIndx","parseInt","removeMessageHandler","key","send","json","dc","stringify","encodeKey","btoa","replace","decodeKey","str","length","slice","atob","shuffle","array","rng","temporaryValue","randomIndex","currentIndex","Math","floor","RANK","RANKS","SUITS","VOID_CARD","shuffledDeck","startFromRankIndex","utils","deck","suit_index","index","suit","rank_index","rank","push","orderedDeck","serializeCard","card","firstChar","charCodeAt","secondChar","String","fromCharCode","serializeCardASCII","charAt","toUpperCase","serializeDeck","deckstr","sameCard","c1","c2","assert","condition","error_m","error","PHASE","SETUP","PLAY","GAMEOVER","ABORT","PHASES","Object","values","SETUP_STATE","PRE_READY","SENT_READY","SENT_START","PLAY_STATE","WAIT_FOR_PLAY","WAIT_FOR_PLAYACK","METHOD","READY","START","PLAYACK","METHODS","METHOD_HANDLER","game","m","phase","abort","state","user","from","hash","players","includes","readyHashes","maybeSendStart","update","nextTurn","cards","playerHands","some","c","legalToPlayCard","actuallyPlayCard","method","acksReceived","userId","maybeStopWaitingForAcks","sendPlayAck","lastPlayedUser","lastPlayedCard","resetPhase","args","startNumbers","myRandom","sort","playedCards","users","initPhase","addListener","listener","listenerIndex","listeners","removeListener","a","randomNumber","keys","randomNumberHash","maybeStartGame","reason","message","encoder","TextEncoder","encode","crypto","subtle","digest","hashBuffer","hashArray","Array","Uint8Array","hashHex","map","b","toString","padStart","join","filter","lastCard","playCard","isMyTurn","sendReady","random","hash_r","l","winner","checkIfWon","finalRandomNumber","forEach","seedrandom","startGame","sendStart","getMyUserId","getOppUserId","oppUserId","x","getMyHand","getOppHand","playerHand","isMyTurnEnabled","getPlayedCards","methods","handlers","Chat","props","useState","chatMessage","setChatMessage","messages","setMessages","onSendMessage","connRef","current","newMessage","oldm","useEffect","p2p","onChange","target","onKeyUp","onClick","style","whiteSpace","Setup","Play","logic","gameRef","setPlayedCards","myHand","setMyHand","oppHand","setOppHand","myUserId","setMyUserId","setOppUserId","selectedCard","setSelectedCard","myTurn","setMyTurn","changeCard","useCallback","currentTarget","updateGameState","disabled","Hand","PlayedCards","MyHand","PlayButton","play","cardstr","secondCharSpades","diff","pass","Deck","SelectableDeck","fontSize","className","Fragment","name","checked","id","htmlFor","GameOver","Game","setPhase","Create1","setOffer","setMyOffer","pc","signalingState","createDataChannel","onopen","onmessage","createOffer","then","d","setLocalDescription","catch","onicecandidate","candidate","localDescription","Create2","joinKey","setJoinKey","offer","answerDesc","RTCSessionDescription","setRemoteDescription","Join1","setAnswer","offerDesc","createAnswer","setMyAnswer","Join2","answer","Welcome","Lobby","myOffer","myAnswer","App","inSetup","setInSetup","useRef","RTCPeerConnection","ondatachannel","channel","oniceconnectionstatechange","iceConnectionState","substr","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.47faa07c.chunk.js","sourcesContent":["const RTC_CONFIG = {\n  iceServers: [\n    { urls: [\"stun:stun.l.google.com:19302\", \"stun:stun2.l.google.com:19302\"] },\n  ],\n};\n\n// var haveGum = navigator.mediaDevices\n//   .getUserMedia({ video: true, audio: true })\n//   .catch(console.log);\n\nexport function createConn() {\n  let conn = {\n    pc: new RTCPeerConnection(RTC_CONFIG),\n    dc: null,\n    messageHandlers: {},\n    messageHandlersIndx: \"0\",\n  };\n  conn.pc.ondatachannel = (e) => {\n    conn.dc = e.channel;\n    conn.dc.onopen = () => onOpen(conn);\n    conn.dc.onmessage = (e) => onMessage(conn, e);\n  };\n  conn.pc.oniceconnectionstatechange = (e) =>\n    console.log(conn.pc.iceConnectionState);\n  return conn;\n}\n\nfunction onOpen(conn) {\n  console.log(\"opened chat!!\");\n  console.log(conn.messageHandlers);\n  const data = { type: \"info\", value: \"successfully opened connection!!\" };\n  for (const indx in conn.messageHandlers) {\n    conn.messageHandlers[indx](data);\n  }\n}\nfunction onMessage(conn, e) {\n  console.log(\"received message!\");\n  console.log(conn.messageHandlers);\n  let data = JSON.parse(e.data);\n  console.log(data);\n  for (const indx in conn.messageHandlers) {\n    conn.messageHandlers[indx](data);\n  }\n}\nexport function addMessageHandler(conn, handler) {\n  const indx = conn.messageHandlersIndx;\n  conn.messageHandlers[indx] = handler;\n  conn.messageHandlersIndx = `${parseInt(indx) + 1}`;\n  return indx;\n}\nexport function removeMessageHandler(conn, key) {\n  if (!conn) return;\n  console.log(`removing key ${key} from conn ${conn}`);\n  delete conn.messageHandlers[key];\n}\n\nexport function sendMessage(conn, message) {\n  send(conn, { type: \"message\", message: message });\n}\nexport function sendData(conn, data) {\n  send(conn, { type: \"data\", ...data });\n}\nexport function send(conn, json) {\n  conn.dc.send(JSON.stringify(json));\n}\n\nexport function createOffer(conn, setOffer) {\n  console.log(\"create offer\");\n  console.log(conn.pc.signalingState);\n  conn.dc = conn.pc.createDataChannel(\"chat\");\n\n  conn.dc.onopen = () => onOpen(conn);\n  conn.dc.onmessage = (e) => onMessage(conn, e);\n\n  // haveGum\n  //   .then(() => conn.pc.createOffer())\n  conn.pc\n    .createOffer()\n    .then((d) => conn.pc.setLocalDescription(d))\n    .catch(console.log);\n\n  conn.pc.onicecandidate = (e) => {\n    if (e.candidate) return;\n    setOffer(encodeKey(JSON.stringify(conn.pc.localDescription)));\n  };\n}\n\nfunction encodeKey(json) {\n  return btoa(json).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeKey(key) {\n  let str = key;\n  if (str.length % 4 !== 0) {\n    str += \"===\".slice(0, 4 - (str.length % 4));\n  }\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  return atob(str);\n}\n\nexport function join(conn, joinKey, setAnswer) {\n  console.log(\"join\");\n  console.log(conn.pc.signalingState);\n  let offerDesc = new RTCSessionDescription(JSON.parse(decodeKey(joinKey)));\n\n  conn.pc\n    .setRemoteDescription(offerDesc)\n    .then(() => conn.pc.createAnswer())\n    .then((d) => conn.pc.setLocalDescription(d))\n    .catch(console.log);\n\n  conn.pc.onicecandidate = (e) => {\n    if (e.candidate) return;\n    setAnswer(encodeKey(JSON.stringify(conn.pc.localDescription)));\n  };\n}\n\nexport function acceptAnswer(conn, joinKey) {\n  console.log(\"join\");\n  console.log(conn.pc.signalingState);\n  var answerDesc = new RTCSessionDescription(JSON.parse(decodeKey(joinKey)));\n  conn.pc.setRemoteDescription(answerDesc).catch(console.log);\n}\n\nexport function numConnections(conn) {\n  // TODO: update this for many players\n  return 1;\n}\n","export function shuffle(array, rng) {\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(rng() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n","import * as utils from \"./utils.js\";\n\nexport const RANK = {\n  ACE: \"A\",\n  TWO: \"2\",\n  THREE: \"3\",\n  FOUR: \"4\",\n  FIVE: \"5\",\n  SIX: \"6\",\n  SEVEN: \"7\",\n  EIGHT: \"8\",\n  NINE: \"9\",\n  TEN: \"10\",\n  JACK: \"J\",\n  QUEEN: \"Q\",\n  KING: \"K\",\n};\nexport const RANKS = [\n  RANK.ACE,\n  RANK.TWO,\n  RANK.THREE,\n  RANK.FOUR,\n  RANK.FIVE,\n  RANK.SIX,\n  RANK.SEVEN,\n  RANK.EIGHT,\n  RANK.NINE,\n  RANK.TEN,\n  RANK.JACK,\n  RANK.QUEEN,\n  RANK.KING,\n]; // dont do Object.values because we want to guarantee order\nexport const SUIT = {\n  SPADES: \"spades\",\n  HEARTS: \"hearts\",\n  DIAMONDS: \"diamonds\",\n  CLUBS: \"clubs\",\n};\nexport const SUITS = [SUIT.SPADES, SUIT.HEARTS, SUIT.DIAMONDS, SUIT.CLUBS]; // dont do Object.values because we want to guarantee order\n\nexport const VOID_CARD = \"VOID_CARD\";\n\n//      card is represented by {rank:, suit:} (why no types :(((()))))\n\nexport function orderedDeck(startFromRankIndex) {\n  if (!startFromRankIndex) startFromRankIndex = 0;\n  let deck = [];\n  let suit_index = 0;\n  let index = 0;\n  for (const suit of SUITS) {\n    let rank_index = 0;\n    for (const rank of RANKS) {\n      if (rank_index >= startFromRankIndex) {\n        deck.push({ rank, suit, rank_index, suit_index, index });\n      }\n      rank_index++;\n      index++;\n    }\n    suit_index++;\n  }\n  return deck;\n}\n\nexport function shuffledDeck(rng, startFromRankIndex) {\n  let deck = orderedDeck(startFromRankIndex);\n  return utils.shuffle(deck, rng);\n}\n\n// users: list of IDs for each user who wants a card\n// return: an object {user_id -> array of cards}, as even as possible, union is all cards, disjoint\nexport function dealShuffledCards(users, rng, startFromRankIndex) {\n  let deck = shuffledDeck(rng, startFromRankIndex);\n  let cards = {};\n  let index = 0;\n  for (const user of users) {\n    cards[user] = [];\n  }\n  while (index < deck.length) {\n    for (const user of users) {\n      cards[user].push(deck[index]);\n      index++;\n    }\n  }\n  return cards;\n}\n\nexport function serializeCard(card) {\n  const aceOfSpades = \"🂡\";\n  const firstChar = aceOfSpades.charCodeAt(0);\n  const secondChar = aceOfSpades.charCodeAt(1);\n  return (\n    String.fromCharCode(firstChar) +\n    String.fromCharCode(\n      secondChar +\n        card.rank_index +\n        card.suit_index * 16 +\n        (card.rank === RANK.QUEEN || card.rank === RANK.KING ? 1 : 0)\n    )\n  );\n}\nexport function deserializeCard(cardstr) {\n  const aceOfSpades = \"🂡\";\n  const secondCharSpades = aceOfSpades.charCodeAt(1);\n  const secondChar = cardstr.charCodeAt(1);\n  const diff = secondChar - secondCharSpades;\n  const suit_index = Math.floor(diff / 16);\n  let rank_index = diff % 16;\n  if (rank_index >= 12) {\n    rank_index--;\n  }\n  return {\n    suit: SUITS[suit_index],\n    rank: RANKS[rank_index],\n    suit_index,\n    rank_index,\n    index: suit_index * 13 + rank_index,\n  };\n}\nexport function serializeCardASCII(card) {\n  return card.rank + card.suit.charAt(0).toUpperCase();\n}\n\nexport function serializeDeck(deck) {\n  let deckstr = \"\";\n  for (const card of deck) {\n    deckstr += serializeCard(card);\n  }\n  return deckstr;\n}\n\nexport function sameCard(c1, c2) {\n  if (c1 === VOID_CARD || c2 === VOID_CARD)\n    return c1 === VOID_CARD && c2 === VOID_CARD;\n  return c1.index === c2.index;\n}\n","export const START_FROM_RANK = 12;\n","export default function assert(condition, error_m) {\n  if (condition) return;\n  console.error(\"assertion failed\");\n  console.error(error_m);\n}\n","// logic.js is intended to hold all game logic\n\nimport seedrandom from \"seedrandom\";\n\nimport * as p2p from \"./p2p.js\";\nimport * as utils from \"./utils.js\";\nimport * as cards from \"./cards.js\";\nimport * as config from \"./config.js\";\n\nimport assert from \"./assert.js\";\n\n// what's the game state?\n// there's a public part and a private part\n// the public part needs to be agreed upon among all players\n// the private part is\n//\n// PUBLIC:\n// for version 1:\n// 1: the middle deck, which has order\n// 2: each player's hand, which does not have order\n//      invariant: all disjoint, union is all cards\n//\n// for version 2:\n// 3: all the rule hashes\n// 4:\n//\n// PRIVATE:\n// for version 2:\n// 1: your own rules (which is in the form of uhhhh)\n//\n//\n//\n// TODO: later version: add signatures to actually be secure\n\n// WIRE PROTOCOL:\n// always assume broadcast messages!!!!!! this allows us to assume synchronicity which makes everything so much simpler\n// 1. setup:\n//  1.1 everyone: READY hashOfRandomNumber userID (number is a 64-bit integers, user id is randomly generated (later should be public key))\n//  1.2 when everyone you have open connections with say READY: START randomNumber  (userID is sent with every message)\n//  1.3 when received all STARTs: verifies all hashes, xors all numbers, seed rng with this, then just pick cards\n//  1.4 using same seed just choose order\n// 2. play:\n//  2.1 someone: PLAY card userID\n//  2.2 everyone else: PLAYACK card user userID\n// 3. abort:\n//  3.1 send ABORT userID to every user, be sad\n\n// ok dont overthink it\n// i think having a hierarchical state thing makes sense\n// this is javascript not rust\n\n// we assume that messages come to people in the order they are sent\n// i.e. we assume that channels are FIFO\n\n// ok so we have:\n// phase = {\"setup\", \"play\", \"gameover\", \"abort\"}\n// each phase has some metadata, which can be public or private\n// the public metadata is always sent over for debugging purposes\n\n// transitions\n// setup:\n//      state = {\"preReady\",\"sentReady\",\"sentStart\"},\n//      players, readyHashes, startNumbers, myRandom\n//\n// play:\n//      nextTurn = index into players\n//      players (order matters),\n//      playedCards (0 bottom, n-1 top),\n//      playerHands (id -> array),\n//      state = {\"waitforplay\", \"waitforack\"}\n//      acksReceived = []\n//      lastPlayedCard\n//      lastPlayedUser\n//\n// gameover: (transitions directly to setup.sentReady)\n//      winner = user_id\n//\n// abort:\n//      (no data)\n\nexport const PHASE = {\n  SETUP: \"SETUP\",\n  PLAY: \"PLAY\",\n  GAMEOVER: \"GAMEOVER\",\n  ABORT: \"ABORT\",\n};\nconst PHASES = Object.values(PHASE);\nconst SETUP_STATE = {\n  PRE_READY: \"PRE_READY\",\n  SENT_READY: \"SENT_READY\",\n  SENT_START: \"SENT_START\",\n};\nconst SETUP_STATES = Object.values(SETUP_STATE);\nconst PLAY_STATE = {\n  WAIT_FOR_PLAY: \"WAIT_FOR_PLAY\",\n  WAIT_FOR_PLAYACK: \"WAIT_FOR_PLAYACK\",\n};\nconst PLAY_STATES = Object.values(PLAY_STATE);\n\nconst METHOD = {\n  READY: \"READY\",\n  START: \"START\",\n  PLAY: \"PLAY\",\n  PLAYACK: \"PLAYACK\",\n  ABORT: \"ABORT\",\n};\nconst METHODS = Object.values(METHOD);\nconst METHOD_HANDLER = {\n  [METHOD.READY]: handleReadyMethod,\n  [METHOD.START]: handleStartMethod,\n  [METHOD.PLAY]: handlePlayMethod,\n  [METHOD.PLAYACK]: handlePlayAckMethod,\n  [METHOD.ABORT]: handleAbortMethod,\n};\nassert(\n  JSON.stringify(METHODS) === JSON.stringify(Object.keys(METHOD_HANDLER)),\n  {\n    methods: METHODS,\n    handlers: METHOD_HANDLER,\n  }\n);\n\nexport function createGame(conn) {\n  // TODO: generate private/public keypair here and let userId be the public key\n  const userId = Math.random().toString(36).substr(2, 9);\n  const game = {\n    conn,\n    listeners: {},\n    listenerIndex: \"0\",\n    userId: userId,\n    phase: null,\n    data: {}, // contains data for every phase\n  };\n  for (const phase of PHASES) {\n    game.data[phase] = {};\n  }\n  initPhase(game, PHASE.SETUP);\n  return game;\n}\nfunction resetPhase(game, phase, args) {\n  assert(PHASES.includes(phase), game);\n  let data = {};\n  if (phase === PHASE.SETUP) {\n    data = {\n      state: SETUP_STATE.PRE_READY,\n      players: [game.userId],\n      readyHashes: {},\n      startNumbers: {},\n      myRandom: null,\n    };\n  } else if (phase === PHASE.PLAY) {\n    // shuffle the player list\n    // note: we need to sort it first before we do it so everyone gets the same list\n\n    data.players = utils.shuffle(\n      [...game.data[PHASE.SETUP].players].sort(),\n      args.rng\n    );\n\n    data.nextTurn = 0;\n\n    data.playedCards = []; // start empty\n\n    // now deal cards\n    data.playerHands = cards.dealShuffledCards(\n      utils.shuffle(data.players, args.rng),\n      args.rng,\n      config.START_FROM_RANK\n    );\n\n    data.state = PLAY_STATE.WAIT_FOR_PLAY;\n\n    data.acksReceived = [];\n    data.lastPlayedCard = null;\n    data.lastPlayedUser = null;\n  }\n  game.data[phase] = data;\n}\nfunction initPhase(game, phase, args) {\n  assert(PHASES.includes(phase), game);\n  resetPhase(game, phase, args);\n  game.phase = phase;\n}\nexport function addListener(game, listener) {\n  const indx = game.listenerIndex;\n  game.listeners[indx] = listener;\n  game.listenerIndex = `${parseInt(indx) + 1}`;\n  return indx;\n}\nexport function removeListener(game, key) {\n  if (!game) return;\n  console.log(`removing key ${key} from game ${game}`);\n  console.log(game);\n  delete game.listeners[key];\n}\n// this function needs to be called every time the game state is updated!!!!!!!!\nfunction update(game) {\n  for (let listener of Object.values(game.listeners)) {\n    listener();\n  }\n}\n\n// m should be on form {data: , method: , ...}\nexport function receive(game, m) {\n  console.log(\"game receiving message!\");\n  console.log(m);\n  if (m.type !== \"data\") {\n    console.log(\"ignoring non-data message\");\n    return;\n  }\n  assert(METHODS.includes(m.method));\n  console.log(METHOD_HANDLER);\n  METHOD_HANDLER[m.method](game, m);\n}\nfunction send(game, m) {\n  // TODO: sign the message\n  m[\"from\"] = game.userId;\n  p2p.sendData(game.conn, m);\n}\n\nfunction unimplemented() {\n  assert(false, \"not implemented yet!!\");\n}\n\nfunction handleReadyMethod(game, m) {\n  // should be in setup phase, or gameover phase\n  if (!(game.phase === PHASE.SETUP || game.phase === PHASE.GAMEOVER))\n    return abort(game);\n  const data = game.data[PHASE.SETUP];\n  // should not have sent start already\n  if (\n    !(\n      data.state === SETUP_STATE.PRE_READY ||\n      data.state === SETUP_STATE.SENT_READY\n    )\n  ) {\n    return abort(game);\n  }\n\n  const user = m.from;\n  const hash = m.hash;\n\n  // shouldn't receive twice; should have different IDs\n  if (data.players.includes(user)) return abort(game);\n\n  data.players.push(user);\n  data.readyHashes[user] = hash;\n\n  // if we have received all, send start\n  maybeSendStart(game);\n\n  update(game);\n}\nasync function handleStartMethod(game, m) {\n  // should be in setup phase\n  if (game.phase !== PHASE.SETUP) return abort(game, \"wrong phase\");\n  const data = game.data[PHASE.SETUP];\n  // should have sent ready (not necessarily should have sent start though)\n  if (\n    !(\n      data.state === SETUP_STATE.SENT_READY ||\n      data.state === SETUP_STATE.SENT_START\n    )\n  ) {\n    return abort(game);\n  }\n\n  const user = m.from;\n  const randomNumber = m.randomNumber;\n\n  // shouldn't receive twice\n  if (Object.keys(data.startNumbers).includes(user)) return abort(game);\n\n  // should receive from verified user\n  if (!data.players.includes(user)) return abort(game, `unknown user ${user}`);\n\n  // assert that the hash is ok\n  const randomNumberHash = await hash(`${randomNumber}`);\n  if (data.readyHashes[user] !== randomNumberHash)\n    return abort(\n      game,\n      `incorrect hash ${randomNumberHash} received for random number ${randomNumber} from user ${user}`\n    );\n\n  // add to numbers\n  data.startNumbers[user] = randomNumber;\n\n  // if we have received all, go to the game!!\n  maybeStartGame(game);\n\n  update(game);\n}\nfunction handlePlayMethod(game, m) {\n  if (game.phase !== PHASE.PLAY) return abort(game, \"wrong phase\");\n  const data = game.data[game.phase];\n  if (data.state !== PLAY_STATE.WAIT_FOR_PLAY)\n    return abort(game, \"wrong state\");\n\n  const user = m.from;\n  const card = m.card;\n\n  // make sure it is this user's turn\n  if (user !== data.players[data.nextTurn]) {\n    return abort(game, \"user tried to make move but it's not their turn\");\n  }\n\n  // make sure this user owns this card (or it is voidcard)\n  if (\n    card !== cards.VOID_CARD &&\n    !data.playerHands[user].some((c) => cards.sameCard(c, card))\n  ) {\n    return abort(game, \"user tried to play card not in their hand\");\n  }\n\n  // make sure the card move is legal\n  if (!legalToPlayCard(game, card)) {\n    return abort(game, \"user tried to play illegal card\");\n  }\n\n  // actually do the move\n  actuallyPlayCard(game, user, card);\n\n  sendPlayAck(game, user, card);\n\n  update(game);\n}\nfunction handlePlayAckMethod(game, m) {\n  if (game.phase !== PHASE.PLAY) return abort(game, \"wrong phase\");\n  const data = game.data[game.phase];\n  if (data.state !== PLAY_STATE.WAIT_FOR_PLAYACK)\n    return abort(game, \"wrong state\");\n\n  const user = m.user;\n  const from = m.from;\n  const card = m.card;\n\n  // make sure the right user n right card was acked\n  if (user !== data.lastPlayedUser) {\n    return abort(game, \"tried to ack the wrong user\");\n  }\n  if (!cards.sameCard(card, data.lastPlayedCard)) {\n    return abort(game, \"tried to ack the wrong card\");\n  }\n\n  if (data.acksReceived.includes(from)) {\n    return abort(game, \"already received ack from this user\");\n  }\n\n  // TODO: verify the zk snarks\n\n  data.acksReceived.push(from);\n\n  maybeStopWaitingForAcks(game);\n\n  update(game);\n}\nfunction handleAbortMethod(game, m) {\n  console.log(\"ABORTING :(((( SAD\");\n  unimplemented();\n\n  update(game);\n}\n\nfunction abort(game, reason) {\n  console.error(\"ABORT GAME :((\");\n  console.error(reason);\n  send(game, { method: METHOD.ABORT, reason });\n  game.phase = PHASE.ABORT;\n\n  update(game);\n}\n\nasync function hash(message) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\"); // convert bytes to hex string\n  return hashHex;\n}\n\nfunction actuallyPlayCard(game, user, card) {\n  const data = game.data[game.phase];\n  data.nextTurn = (data.nextTurn + 1) % data.players.length;\n  data.state = PLAY_STATE.WAIT_FOR_PLAYACK;\n  data.lastPlayedCard = card;\n  data.lastPlayedUser = user;\n  if (card !== cards.VOID_CARD) {\n    data.playedCards.push(card);\n    data.playerHands[user] = data.playerHands[user].filter(\n      (c) => c.index !== card.index\n    );\n  }\n  update(game);\n}\n\nfunction legalToPlayCard(game, card) {\n  const data = game.data[game.phase];\n  // always ok to pass\n  if (card === cards.VOID_CARD) return true;\n  // first move always legal\n  if (data.playedCards.length === 0) return true;\n  // either suit or rank must be the same\n  const lastCard = data.playedCards[data.playedCards.length - 1];\n  return lastCard.suit === card.suit || lastCard.rank === card.rank;\n}\n\nexport function playCard(game, card) {\n  assert(game.phase === PHASE.PLAY && isMyTurn(game), game);\n  const data = game.data[game.phase];\n  assert(data.state === PLAY_STATE.WAIT_FOR_PLAY, game);\n  assert(\n    card === cards.VOID_CARD ||\n      data.playerHands[game.userId].some((c) => cards.sameCard(c, card)),\n    game\n  );\n  console.log(`play card!`);\n  console.log(card);\n\n  assert(legalToPlayCard(game, card), game);\n\n  send(game, { method: METHOD.PLAY, card });\n\n  actuallyPlayCard(game, game.userId, card);\n  update(game);\n}\n\nexport function restartGame(game) {\n  game.phase = PHASE.SETUP;\n\n  sendReady(game);\n}\n\nexport async function sendReady(game) {\n  assert(game.phase === PHASE.SETUP, game);\n  const data = game.data[PHASE.SETUP];\n  assert(data.state === SETUP_STATE.PRE_READY, game);\n  // generate a random number\n  data.myRandom = Math.floor(Math.random() * 2 ** 64);\n  // hash the random number\n  const hash_r = await hash(`${data.myRandom}`);\n  console.log(hash_r);\n  data.readyHashes[game.userId] = hash_r;\n  send(game, { method: METHOD.READY, hash: hash_r });\n  data.state = SETUP_STATE.SENT_READY;\n  maybeSendStart(game);\n\n  update(game);\n}\n\nfunction checkIfWon(game) {\n  assert(game.phase === PHASE.PLAY, game);\n  const data = game.data[game.phase];\n  assert(data.state === PLAY_STATE.WAIT_FOR_PLAY, game);\n\n  for (const user of data.players) {\n    if (data.playerHands[user].length === 0) {\n      // someone won!!!!\n      // assert only one player won\n      assert(\n        Object.values(data.playerHands).filter((l) => l.length === 0).length ===\n          1\n      );\n\n      game.phase = PHASE.GAMEOVER;\n      game.data[PHASE.GAMEOVER].winner = user;\n    }\n  }\n}\n\nfunction maybeStopWaitingForAcks(game) {\n  const data = game.data[game.phase];\n  // everyone except the player needs to ack the card\n  if (data.acksReceived.length === data.players.length - 1) {\n    data.state = PLAY_STATE.WAIT_FOR_PLAY;\n    data.acksReceived = [];\n    data.lastPlayedCard = null;\n    data.lastPlayedUser = null;\n\n    // check if someone won\n    checkIfWon(game);\n\n    update(game);\n  }\n}\n\nfunction sendPlayAck(game, user, card) {\n  assert(game.phase === PHASE.PLAY, game);\n  const data = game.data[game.phase];\n  assert(data.state === PLAY_STATE.WAIT_FOR_PLAYACK, game);\n\n  // TODO: run the zk rule snarks to determine penalties\n\n  send(game, { method: METHOD.PLAYACK, card, user });\n\n  assert(!data.acksReceived.includes(game.userId), game);\n  data.acksReceived.push(game.userId);\n\n  maybeStopWaitingForAcks(game);\n\n  update(game);\n}\n\nfunction maybeStartGame(game) {\n  const data = game.data[game.phase];\n  if (data.players.length === Object.keys(data.startNumbers).length) {\n    startGame(game);\n  }\n}\nfunction startGame(game) {\n  assert(game.phase === PHASE.SETUP);\n  const data = game.data[game.phase];\n  assert(data.state === SETUP_STATE.SENT_START, game);\n\n  // xor all the random numbers (which means that as long as at least 1 person honest, it is random)\n  let finalRandomNumber = 0;\n  Object.values(data.startNumbers).forEach((randomNumber) => {\n    finalRandomNumber ^= randomNumber;\n  });\n\n  console.log(`final randomness: ${finalRandomNumber}`);\n  // use this random number as the seed of an rng\n  let rng = seedrandom(`${finalRandomNumber}`);\n\n  // now we can transition to the game phase\n  // delete the old game object properties\n  initPhase(game, PHASE.PLAY, { rng });\n  resetPhase(game, PHASE.SETUP);\n\n  console.log(\"STARTING GAME!!!! exciting :)))\");\n  console.log(game);\n\n  update(game);\n}\n\nfunction maybeSendStart(game) {\n  const data = game.data[PHASE.SETUP];\n  if (\n    p2p.numConnections(game.conn) ===\n    Object.keys(data.readyHashes).length - 1\n  ) {\n    assert(data.players.length === Object.keys(data.readyHashes).length, game);\n    sendStart(game);\n  }\n}\nfunction sendStart(game) {\n  assert(game.phase === PHASE.SETUP, game);\n  const data = game.data[game.phase];\n  assert(data.state === SETUP_STATE.SENT_READY, game);\n\n  send(game, { method: METHOD.START, randomNumber: data.myRandom });\n\n  data.startNumbers[game.userId] = data.myRandom;\n  data.state = SETUP_STATE.SENT_START;\n\n  maybeStartGame(game);\n\n  update(game);\n}\n\n// convenience for 2 players\n// TODO: update this for more players\n\nexport function getMyUserId(game) {\n  return game.userId;\n}\nexport function getOppUserId(game) {\n  const data = game.data[PHASE.PLAY];\n  const oppUserId = data.players.filter((x) => x !== getMyUserId(game))[0];\n  console.log(`opp user id: ${oppUserId}`);\n  return oppUserId;\n}\nexport function getMyHand(game) {\n  const data = game.data[PHASE.PLAY];\n  return data.playerHands[getMyUserId(game)];\n}\nexport function getOppHand(game) {\n  const data = game.data[PHASE.PLAY];\n  const playerHand = data.playerHands[getOppUserId(game)];\n  console.log(\"player hand!\");\n  console.log(JSON.stringify(playerHand));\n  return playerHand;\n}\nfunction isMyTurn(game) {\n  const data = game.data[PHASE.PLAY];\n  return getMyUserId(game) === data.players[data.nextTurn];\n}\nexport function isMyTurnEnabled(game) {\n  const data = game.data[PHASE.PLAY];\n  return isMyTurn(game) && data.state === PLAY_STATE.WAIT_FOR_PLAY;\n}\n\nexport function getPlayedCards(game) {\n  const data = game.data[PHASE.PLAY];\n  return data.playedCards;\n}\n\nexport function getWinner(game) {\n  const data = game.data[PHASE.GAMEOVER];\n  return data.winner;\n}\n","import React from \"react\";\nimport { useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\n\nexport function Chat(props) {\n  const [chatMessage, setChatMessage] = useState(\"\");\n  const [messages, setMessages] = useState(\"\");\n\n  function onSendMessage() {\n    p2p.sendMessage(props.connRef.current, chatMessage);\n    newMessage(chatMessage);\n    setChatMessage(\"\");\n  }\n\n  function newMessage(m) {\n    setMessages((oldm) => {\n      if (oldm === \"\") return m;\n      return m + \"\\n\" + oldm;\n    });\n  }\n\n  useEffect(() => {\n    const indx = p2p.addMessageHandler(props.connRef.current, (m) => {\n      if (m.type === \"message\") return newMessage(m.message);\n      newMessage(JSON.stringify(m));\n    });\n    return () => {\n      console.log(`cleaning up chat!!! index ${indx}`);\n      p2p.removeMessageHandler(props.connRef.current, indx);\n    };\n  }, [props.connRef]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={chatMessage}\n        onChange={(e) => setChatMessage(e.target.value)}\n        onKeyUp={(e) => (e.key === \"Enter\" ? onSendMessage() : 0)}\n      ></input>\n      <button onClick={onSendMessage}>Send message</button>\n      <p style={{ whiteSpace: \"pre-line\" }}>{messages}</p>\n    </div>\n  );\n}\n","import \"./Game.css\";\nimport React from \"react\";\nimport { useCallback, useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\nimport * as logic from \"./logic.js\";\nimport * as cards from \"./cards.js\";\n\nimport { Chat } from \"./Chat.js\";\n\nfunction Setup() {\n  return <div>Waiting for everyone else to press start...</div>;\n}\n\nfunction Play(props) {\n  const [playedCards, setPlayedCards] = useState(\n    logic.getPlayedCards(props.gameRef.current)\n  );\n  const [myHand, setMyHand] = useState(logic.getMyHand(props.gameRef.current));\n  const [oppHand, setOppHand] = useState(\n    logic.getOppHand(props.gameRef.current)\n  );\n  const [myUserId, setMyUserId] = useState(\n    logic.getMyUserId(props.gameRef.current)\n  );\n  const [oppUserId, setOppUserId] = useState(\n    logic.getOppUserId(props.gameRef.current)\n  );\n  const [selectedCard, setSelectedCard] = useState(null);\n  const [myTurn, setMyTurn] = useState(\n    logic.isMyTurnEnabled(props.gameRef.current)\n  );\n  const changeCard = useCallback((e) => {\n    setSelectedCard(e.currentTarget.value);\n  }, []);\n\n  const updateGameState = useCallback(() => {\n    setPlayedCards(logic.getPlayedCards(props.gameRef.current));\n    setMyHand(logic.getMyHand(props.gameRef.current));\n    setOppHand(logic.getOppHand(props.gameRef.current));\n    setMyUserId(logic.getMyUserId(props.gameRef.current));\n    setOppUserId(logic.getOppUserId(props.gameRef.current));\n    setMyTurn(logic.isMyTurnEnabled(props.gameRef.current));\n  }, [props.gameRef]);\n\n  useEffect(() => {\n    const indx = logic.addListener(props.gameRef.current, updateGameState);\n    return () => {\n      logic.removeListener(props.gameRef.current, indx);\n    };\n  }, [props.gameRef, updateGameState]);\n\n  return (\n    <div>\n      {props.disabled || \"Playing the game!!!\"}\n      <hr />\n      <Hand cards={oppHand} user={oppUserId} />\n      <PlayedCards cards={playedCards} />\n      <MyHand\n        cards={myHand}\n        user={myUserId}\n        changeCard={changeCard}\n        selectedCard={selectedCard}\n      />\n      <PlayButton\n        disabled={!myTurn || props.disabled}\n        play={() =>\n          logic.playCard(\n            props.gameRef.current,\n            cards.deserializeCard(selectedCard)\n          )\n        }\n        pass={() => logic.playCard(props.gameRef.current, cards.VOID_CARD)}\n      />\n    </div>\n  );\n}\n\nfunction PlayButton(props) {\n  return (\n    <div>\n      <button onClick={props.play} disabled={props.disabled}>\n        Play!\n      </button>\n      <button onClick={props.pass} disabled={props.disabled}>\n        Pass\n      </button>\n    </div>\n  );\n}\n\nfunction PlayedCards(props) {\n  return (\n    <div>\n      played cards: <Deck cards={props.cards} />\n    </div>\n  );\n}\n\nfunction Hand(props) {\n  return (\n    <div>\n      {props.user}'s cards:\n      <Deck cards={props.cards} />\n    </div>\n  );\n}\nfunction MyHand(props) {\n  return (\n    <div>\n      my cards:\n      <SelectableDeck\n        cards={props.cards}\n        changeCard={props.changeCard}\n        selectedCard={props.selectedCard}\n      />\n    </div>\n  );\n}\nfunction Deck(props) {\n  if (props.cards.length === 0) {\n    return <div>(none)</div>;\n  }\n  return (\n    <div style={{ fontSize: \"3em\" }}>{cards.serializeDeck(props.cards)}</div>\n  );\n}\nfunction SelectableDeck(props) {\n  if (props.cards.length === 0) {\n    return <div>(none)</div>;\n  }\n  return (\n    <div style={{ fontSize: \"3em\" }} className=\"SelectableDeck\">\n      {props.cards.map((card, index) => {\n        return (\n          <React.Fragment key={`mycardsfragment${index}`}>\n            <input\n              type=\"radio\"\n              name=\"mycards\"\n              value={cards.serializeCard(card)}\n              checked={props.selectedCard === cards.serializeCard(card)}\n              onChange={props.changeCard}\n              id={cards.serializeCardASCII(card)}\n              key={`mycardsradio${index}`}\n            />\n            <label\n              htmlFor={cards.serializeCardASCII(card)}\n              key={`mycardslabel${index}`}\n            >\n              {cards.serializeCard(card)}\n            </label>\n          </React.Fragment>\n        );\n      })}\n    </div>\n  );\n}\n\nfunction GameOver(props) {\n  return (\n    <div>\n      <div style={{ fontSize: \"2em\" }}>\n        Game is over!!!! {props.winner} won!\n      </div>\n      <button onClick={() => logic.restartGame(props.gameRef.current)}>\n        Play again!\n      </button>\n    </div>\n  );\n}\n\nexport function Game(props) {\n  const [phase, setPhase] = useState(props.gameRef.current.phase);\n  const [myUserId, setMyUserId] = useState(\n    logic.getMyUserId(props.gameRef.current)\n  );\n\n  const updateGameState = useCallback(() => {\n    setPhase(props.gameRef.current.phase);\n    setMyUserId(logic.getMyUserId(props.gameRef.current));\n  }, [props.gameRef]);\n\n  useEffect(() => {\n    const indx = logic.addListener(props.gameRef.current, updateGameState);\n    return () => {\n      logic.removeListener(props.gameRef.current, indx);\n    };\n  }, [props.gameRef, updateGameState]);\n\n  return (\n    <div>\n      welcome to the game, {myUserId}!\n      <hr />\n      {phase === logic.PHASE.GAMEOVER && (\n        <GameOver\n          gameRef={props.gameRef}\n          winner={logic.getWinner(props.gameRef.current)}\n        />\n      )}\n      {phase === logic.PHASE.SETUP && <Setup />}\n      {(phase === logic.PHASE.PLAY || phase === logic.PHASE.GAMEOVER) && (\n        <Play\n          gameRef={props.gameRef}\n          disabled={phase === logic.PHASE.GAMEOVER}\n        />\n      )}\n      <hr />\n      <Chat connRef={props.connRef} />\n    </div>\n  );\n}\n","import \"./App.css\";\nimport React from \"react\";\nimport { useCallback, useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\nimport * as logic from \"./logic.js\";\n\nimport { Game } from \"./Game.js\";\nimport { Chat } from \"./Chat.js\";\n\nfunction Create1(props) {\n  return (\n    <div>\n      <button\n        onClick={() => p2p.createOffer(props.connRef.current, props.setMyOffer)}\n      >\n        Create game\n      </button>\n    </div>\n  );\n}\n\nfunction Create2(props) {\n  const [joinKey, setJoinKey] = useState(\"\");\n  return (\n    <div>\n      send this message to your friends: <code>{props.offer}</code>\n      <br />\n      input their answer:\n      <input\n        type=\"text\"\n        value={joinKey}\n        onChange={(e) => setJoinKey(e.target.value)}\n      ></input>\n      <button onClick={() => p2p.acceptAnswer(props.connRef.current, joinKey)}>\n        Add player\n      </button>\n    </div>\n  );\n}\n\nfunction Join1(props) {\n  const [joinKey, setJoinKey] = useState(\"\");\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={joinKey}\n        onChange={(e) => setJoinKey(e.target.value)}\n      ></input>\n      <button\n        onClick={() =>\n          p2p.join(props.connRef.current, joinKey, props.setMyAnswer)\n        }\n      >\n        Join\n      </button>\n    </div>\n  );\n}\n\nfunction Join2(props) {\n  return (\n    <div>\n      send this message to your friends: <code>{props.answer}</code>\n      <br />\n    </div>\n  );\n}\n\nfunction Welcome(props) {\n  console.log(props.connRef);\n  return (\n    <div>\n      <Create1 connRef={props.connRef} setMyOffer={props.setMyOffer} />\n      <br />\n      <Join1 connRef={props.connRef} setMyAnswer={props.setMyAnswer} />\n      <br />\n    </div>\n  );\n}\n\nfunction Lobby(props) {\n  return (\n    <div>\n      {props.offer ? (\n        <Create2 connRef={props.connRef} offer={props.offer} />\n      ) : (\n        <Join2 connRef={props.connRef} answer={props.answer} />\n      )}\n      <hr />\n      Participants list: idk\n      <br />\n      <hr />\n      <button onClick={props.startGame}>Start game!</button>\n      <hr />\n      <Chat connRef={props.connRef} />\n    </div>\n  );\n}\n\nfunction Setup(props) {\n  const [myOffer, setMyOffer] = useState(null);\n  const [myAnswer, setMyAnswer] = useState(null);\n\n  if (myOffer || myAnswer) {\n    return (\n      <Lobby\n        connRef={props.connRef}\n        offer={myOffer}\n        answer={myAnswer}\n        startGame={props.startGame}\n      />\n    );\n  } else {\n    return (\n      <React.Fragment>\n        <Welcome\n          connRef={props.connRef}\n          setMyOffer={setMyOffer}\n          setMyAnswer={setMyAnswer}\n        />\n      </React.Fragment>\n    );\n  }\n}\n\nfunction App() {\n  const [inSetup, setInSetup] = useState(true);\n  const connRef = useRef();\n  const gameRef = useRef();\n\n  const startGame = useCallback(() => {\n    setInSetup(false);\n    logic.sendReady(gameRef.current);\n  }, [gameRef]);\n\n  useEffect(() => {\n    connRef.current = p2p.createConn();\n    gameRef.current = logic.createGame(connRef.current);\n  }, []);\n\n  useEffect(() => {\n    const indx = p2p.addMessageHandler(connRef.current, (m) =>\n      logic.receive(gameRef.current, m)\n    );\n    return () => {\n      p2p.removeMessageHandler(connRef.current, indx);\n    };\n  }, [connRef, gameRef]);\n\n  return (\n    <div className=\"App\">\n      {inSetup && <Setup connRef={connRef} startGame={startGame} />}\n      {!inSetup && <Game connRef={connRef} gameRef={gameRef} />}\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}