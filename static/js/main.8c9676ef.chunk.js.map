{"version":3,"sources":["p2p.js","utils.js","cards.js","assert.js","logic.js","Chat.js","Game.js","App.js","reportWebVitals.js","index.js"],"names":["RTC_CONFIG","iceServers","urls","onOpen","conn","console","log","messageHandlers","data","type","value","indx","onMessage","e","JSON","parse","addMessageHandler","handler","messageHandlersIndx","parseInt","removeMessageHandler","key","send","json","dc","stringify","encodeKey","btoa","replace","decodeKey","str","length","slice","atob","shuffle","array","rng","temporaryValue","randomIndex","currentIndex","Math","floor","RANK","RANKS","SUITS","shuffledDeck","utils","deck","suit_index","index","suit","rank_index","rank","push","orderedDeck","serializeCard","card","firstChar","charCodeAt","secondChar","String","fromCharCode","serializeCardASCII","charAt","toUpperCase","serializeDeck","deckstr","assert","condition","error_m","error","PHASE","SETUP","PLAY","GAMEOVER","ABORT","SETUP_STATE","Object","values","PRE_READY","SENT_READY","SENT_START","PLAY_STATE","WAIT_FOR_PLAY","WAIT_FOR_PLAYACK","METHOD","READY","START","PLAYACK","METHODS","METHOD_HANDLER","game","m","phase","abort","state","user","from","hash","players","includes","readyHashes","maybeSendStart","update","nextTurn","playerHands","some","c","legalToPlayCard","actuallyPlayCard","method","acksReceived","userId","maybeStopWaitingForAcks","sendPlayAck","lastPlayedUser","lastPlayedCard","addListener","listener","listenerIndex","listeners","removeListener","a","randomNumber","keys","startNumbers","randomNumberHash","maybeStartGame","reason","message","encoder","TextEncoder","encode","crypto","subtle","digest","hashBuffer","hashArray","Array","Uint8Array","hashHex","map","b","toString","padStart","join","playedCards","filter","lastCard","myRandom","random","hash_r","finalRandomNumber","forEach","seedrandom","sort","users","cards","startGame","sendStart","getMyUserId","getOppUserId","x","getMyHand","getOppHand","isMyTurn","isMyTurnEnabled","methods","handlers","Chat","props","useState","chatMessage","setChatMessage","messages","setMessages","onSendMessage","connRef","current","newMessage","oldm","useEffect","p2p","onChange","target","onKeyUp","onClick","style","whiteSpace","Setup","Play","gameRef","setPlayedCards","logic","myHand","setMyHand","oppHand","setOppHand","myUserId","setMyUserId","oppUserId","setOppUserId","selectedCard","setSelectedCard","myTurn","setMyTurn","changeCard","useCallback","currentTarget","updateGameState","Hand","PlayedCards","MyHand","PlayButton","play","cardstr","secondCharSpades","diff","disabled","Deck","SelectableDeck","fontSize","className","Fragment","name","checked","id","htmlFor","Game","setPhase","Create1","setOffer","setMyOffer","pc","signalingState","createDataChannel","onopen","onmessage","createOffer","then","d","setLocalDescription","catch","onicecandidate","candidate","localDescription","Create2","joinKey","setJoinKey","offer","answerDesc","RTCSessionDescription","setRemoteDescription","Join1","setAnswer","offerDesc","createAnswer","setMyAnswer","Join2","answer","Welcome","Lobby","myOffer","myAnswer","App","inSetup","setInSetup","useRef","RTCPeerConnection","ondatachannel","channel","oniceconnectionstatechange","iceConnectionState","substr","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8c9676ef.chunk.js","sourcesContent":["const RTC_CONFIG = {\n  iceServers: [\n    { urls: [\"stun:stun.l.google.com:19302\", \"stun:stun2.l.google.com:19302\"] },\n  ],\n};\n\n// var haveGum = navigator.mediaDevices\n//   .getUserMedia({ video: true, audio: true })\n//   .catch(console.log);\n\nexport function createConn() {\n  let conn = {\n    pc: new RTCPeerConnection(RTC_CONFIG),\n    dc: null,\n    messageHandlers: {},\n    messageHandlersIndx: \"0\",\n  };\n  conn.pc.ondatachannel = (e) => {\n    conn.dc = e.channel;\n    conn.dc.onopen = () => onOpen(conn);\n    conn.dc.onmessage = (e) => onMessage(conn, e);\n  };\n  conn.pc.oniceconnectionstatechange = (e) =>\n    console.log(conn.pc.iceConnectionState);\n  return conn;\n}\n\nfunction onOpen(conn) {\n  console.log(\"opened chat!!\");\n  console.log(conn.messageHandlers);\n  const data = { type: \"info\", value: \"successfully opened connection!!\" };\n  for (const indx in conn.messageHandlers) {\n    conn.messageHandlers[indx](data);\n  }\n}\nfunction onMessage(conn, e) {\n  console.log(\"received message!\");\n  console.log(conn.messageHandlers);\n  let data = JSON.parse(e.data);\n  console.log(data);\n  for (const indx in conn.messageHandlers) {\n    conn.messageHandlers[indx](data);\n  }\n}\nexport function addMessageHandler(conn, handler) {\n  const indx = conn.messageHandlersIndx;\n  conn.messageHandlers[indx] = handler;\n  conn.messageHandlersIndx = `${parseInt(indx) + 1}`;\n  return indx;\n}\nexport function removeMessageHandler(conn, key) {\n  if (!conn) return;\n  console.log(`removing key ${key} from conn ${conn}`);\n  delete conn.messageHandlers[key];\n}\n\nexport function sendMessage(conn, message) {\n  send(conn, { type: \"message\", message: message });\n}\nexport function sendData(conn, data) {\n  send(conn, { type: \"data\", ...data });\n}\nexport function send(conn, json) {\n  conn.dc.send(JSON.stringify(json));\n}\n\nexport function createOffer(conn, setOffer) {\n  console.log(\"create offer\");\n  console.log(conn.pc.signalingState);\n  conn.dc = conn.pc.createDataChannel(\"chat\");\n\n  conn.dc.onopen = () => onOpen(conn);\n  conn.dc.onmessage = (e) => onMessage(conn, e);\n\n  // haveGum\n  //   .then(() => conn.pc.createOffer())\n  conn.pc\n    .createOffer()\n    .then((d) => conn.pc.setLocalDescription(d))\n    .catch(console.log);\n\n  conn.pc.onicecandidate = (e) => {\n    if (e.candidate) return;\n    setOffer(encodeKey(JSON.stringify(conn.pc.localDescription)));\n  };\n}\n\nfunction encodeKey(json) {\n  return btoa(json).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nfunction decodeKey(key) {\n  let str = key;\n  if (str.length % 4 !== 0) {\n    str += \"===\".slice(0, 4 - (str.length % 4));\n  }\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  return atob(str);\n}\n\nexport function join(conn, joinKey, setAnswer) {\n  console.log(\"join\");\n  console.log(conn.pc.signalingState);\n  let offerDesc = new RTCSessionDescription(JSON.parse(decodeKey(joinKey)));\n\n  conn.pc\n    .setRemoteDescription(offerDesc)\n    .then(() => conn.pc.createAnswer())\n    .then((d) => conn.pc.setLocalDescription(d))\n    .catch(console.log);\n\n  conn.pc.onicecandidate = (e) => {\n    if (e.candidate) return;\n    setAnswer(encodeKey(JSON.stringify(conn.pc.localDescription)));\n  };\n}\n\nexport function acceptAnswer(conn, joinKey) {\n  console.log(\"join\");\n  console.log(conn.pc.signalingState);\n  var answerDesc = new RTCSessionDescription(JSON.parse(decodeKey(joinKey)));\n  conn.pc.setRemoteDescription(answerDesc).catch(console.log);\n}\n\nexport function numConnections(conn) {\n  // TODO: update this for many players\n  return 1;\n}\n","export function shuffle(array, rng) {\n  var currentIndex = array.length,\n    temporaryValue,\n    randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(rng() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n","import * as utils from \"./utils.js\";\n\nexport const RANK = {\n  ACE: \"A\",\n  TWO: \"2\",\n  THREE: \"3\",\n  FOUR: \"4\",\n  FIVE: \"5\",\n  SIX: \"6\",\n  SEVEN: \"7\",\n  EIGHT: \"8\",\n  NINE: \"9\",\n  TEN: \"10\",\n  JACK: \"J\",\n  QUEEN: \"Q\",\n  KING: \"K\",\n};\nexport const RANKS = [\n  RANK.ACE,\n  RANK.TWO,\n  RANK.THREE,\n  RANK.FOUR,\n  RANK.FIVE,\n  RANK.SIX,\n  RANK.SEVEN,\n  RANK.EIGHT,\n  RANK.NINE,\n  RANK.TEN,\n  RANK.JACK,\n  RANK.QUEEN,\n  RANK.KING,\n]; // dont do Object.values because we want to guarantee order\nexport const SUIT = {\n  SPADES: \"spades\",\n  HEARTS: \"hearts\",\n  DIAMONDS: \"diamonds\",\n  CLUBS: \"clubs\",\n};\nexport const SUITS = [SUIT.SPADES, SUIT.HEARTS, SUIT.DIAMONDS, SUIT.CLUBS]; // dont do Object.values because we want to guarantee order\n\n//      card is represented by {rank:, suit:} (why no types :(((()))))\n\nexport function orderedDeck() {\n  let deck = [];\n  let suit_index = 0;\n  let index = 0;\n  for (const suit of SUITS) {\n    let rank_index = 0;\n    for (const rank of RANKS) {\n      deck.push({ rank, suit, rank_index, suit_index, index });\n      rank_index++;\n      index++;\n    }\n    suit_index++;\n  }\n  return deck;\n}\n\nexport function shuffledDeck(rng) {\n  let deck = orderedDeck();\n  return utils.shuffle(deck, rng);\n}\n\n// users: list of IDs for each user who wants a card\n// return: an object {user_id -> array of cards}, as even as possible, union is all cards, disjoint\nexport function dealShuffledCards(users, rng) {\n  let deck = shuffledDeck(rng);\n  let cards = {};\n  let index = 0;\n  for (const user of users) {\n    cards[user] = [];\n  }\n  while (index < deck.length) {\n    for (const user of users) {\n      cards[user].push(deck[index]);\n      index++;\n    }\n  }\n  return cards;\n}\n\nexport function serializeCard(card) {\n  const aceOfSpades = \"🂡\";\n  const firstChar = aceOfSpades.charCodeAt(0);\n  const secondChar = aceOfSpades.charCodeAt(1);\n  return (\n    String.fromCharCode(firstChar) +\n    String.fromCharCode(\n      secondChar +\n        card.rank_index +\n        card.suit_index * 16 +\n        (card.rank === RANK.QUEEN || card.rank === RANK.KING ? 1 : 0)\n    )\n  );\n}\nexport function deserializeCard(cardstr) {\n  const aceOfSpades = \"🂡\";\n  const secondCharSpades = aceOfSpades.charCodeAt(1);\n  const secondChar = cardstr.charCodeAt(1);\n  const diff = secondChar - secondCharSpades;\n  const suit_index = Math.floor(diff / 16);\n  let rank_index = diff % 16;\n  if (rank_index >= 12) {\n    rank_index--;\n  }\n  return {\n    suit: SUITS[suit_index],\n    rank: RANKS[rank_index],\n    suit_index,\n    rank_index,\n    index: suit_index * 13 + rank_index,\n  };\n}\nexport function serializeCardASCII(card) {\n  return card.rank + card.suit.charAt(0).toUpperCase();\n}\n\nexport function serializeDeck(deck) {\n  let deckstr = \"\";\n  for (const card of deck) {\n    deckstr += serializeCard(card);\n  }\n  return deckstr;\n}\n","export default function assert(condition, error_m) {\n  if (condition) return;\n  console.error(\"assertion failed\");\n  console.error(error_m);\n}\n","// logic.js is intended to hold all game logic\n\nimport seedrandom from \"seedrandom\";\n\nimport * as p2p from \"./p2p.js\";\nimport * as utils from \"./utils.js\";\nimport * as cards from \"./cards.js\";\n\nimport assert from \"./assert.js\";\n\n// what's the game state?\n// there's a public part and a private part\n// the public part needs to be agreed upon among all players\n// the private part is\n//\n// PUBLIC:\n// for version 1:\n// 1: the middle deck, which has order\n// 2: each player's hand, which does not have order\n//      invariant: all disjoint, union is all cards\n//\n// for version 2:\n// 3: all the rule hashes\n// 4:\n//\n// PRIVATE:\n// for version 2:\n// 1: your own rules (which is in the form of uhhhh)\n//\n//\n//\n// TODO: later version: add signatures to actually be secure\n\n// WIRE PROTOCOL:\n// always assume broadcast messages!!!!!! this allows us to assume synchronicity which makes everything so much simpler\n// 1. setup:\n//  1.1 everyone: READY hashOfRandomNumber userID (number is a 64-bit integers, user id is randomly generated (later should be public key))\n//  1.2 when everyone you have open connections with say READY: START randomNumber  (userID is sent with every message)\n//  1.3 when received all STARTs: verifies all hashes, xors all numbers, seed rng with this, then just pick cards\n//  1.4 using same seed just choose order\n// 2. play:\n//  2.1 someone: PLAY card userID\n//  2.2 everyone else: PLAYACK card user userID\n// 3. abort:\n//  3.1 send ABORT userID to every user, be sad\n\n// ok dont overthink it\n// i think having a hierarchical state thing makes sense\n// this is javascript not rust\n\n// we assume that messages come to people in the order they are sent\n// i.e. we assume that channels are FIFO\n\n// ok so we have:\n// phase = {\"setup\", \"play\", \"gameover\", \"abort\"}\n// each phase has some metadata, which can be public or private\n// the public metadata is always sent over for debugging purposes\n\n// transitions\n// setup:\n//      state = {\"preReady\",\"sentReady\",\"sentStart\"},\n//      players, readyHashes, startNumbers, myRandom\n//\n// play:\n//      nextTurn = index into players\n//      players (order matters),\n//      playedCards (0 bottom, n-1 top),\n//      playerHands (id -> array),\n//      state = {\"waitforplay\", \"waitforack\"}\n//      acksReceived = []\n//      lastPlayedCard\n//      lastPlayedUser\n//\n// gameover: (transitions directly to setup.sentReady)\n//      winner = user_id\n//\n// abort:\n//      (no data)\n\nexport const PHASE = {\n  SETUP: \"SETUP\",\n  PLAY: \"PLAY\",\n  GAMEOVER: \"GAMEOVER\",\n  ABORT: \"ABORT\",\n};\nconst PHASES = Object.values(PHASE);\nconst SETUP_STATE = {\n  PRE_READY: \"PRE_READY\",\n  SENT_READY: \"SENT_READY\",\n  SENT_START: \"SENT_START\",\n};\nconst SETUP_STATES = Object.values(SETUP_STATE);\nconst PLAY_STATE = {\n  WAIT_FOR_PLAY: \"WAIT_FOR_PLAY\",\n  WAIT_FOR_PLAYACK: \"WAIT_FOR_PLAYACK\",\n};\nconst PLAY_STATES = Object.values(PLAY_STATE);\n\nconst METHOD = {\n  READY: \"READY\",\n  START: \"START\",\n  PLAY: \"PLAY\",\n  PLAYACK: \"PLAYACK\",\n  ABORT: \"ABORT\",\n};\nconst METHODS = Object.values(METHOD);\nconst METHOD_HANDLER = {\n  [METHOD.READY]: handleReadyMethod,\n  [METHOD.START]: handleStartMethod,\n  [METHOD.PLAY]: handlePlayMethod,\n  [METHOD.PLAYACK]: handlePlayAckMethod,\n  [METHOD.ABORT]: handleAbortMethod,\n};\nassert(\n  JSON.stringify(METHODS) === JSON.stringify(Object.keys(METHOD_HANDLER)),\n  {\n    methods: METHODS,\n    handlers: METHOD_HANDLER,\n  }\n);\n\nexport function createGame(conn) {\n  // TODO: generate private/public keypair here and let userId be the public key\n  const userId = Math.random().toString(36).substr(2, 9);\n  const game = {\n    conn,\n    listeners: {},\n    listenerIndex: \"0\",\n    phase: PHASE.SETUP,\n    userId: userId,\n    state: SETUP_STATE.PRE_READY,\n    players: [userId],\n    readyHashes: {},\n    startNumbers: {},\n    myRandom: null,\n  };\n  return game;\n}\nexport function addListener(game, listener) {\n  const indx = game.listenerIndex;\n  game.listeners[indx] = listener;\n  game.listenerIndex = `${parseInt(indx) + 1}`;\n  return indx;\n}\nexport function removeListener(game, key) {\n  if (!game) return;\n  console.log(`removing key ${key} from game ${game}`);\n  console.log(game);\n  delete game.listeners[key];\n}\n// this function needs to be called every time the game state is updated!!!!!!!!\nfunction update(game) {\n  for (let listener of Object.values(game.listeners)) {\n    listener();\n  }\n}\n\n// m should be on form {data: , method: , ...}\nexport function receive(game, m) {\n  console.log(\"game receiving message!\");\n  console.log(m);\n  if (m.type !== \"data\") {\n    console.log(\"ignoring non-data message\");\n    return;\n  }\n  assert(METHODS.includes(m.method));\n  console.log(METHOD_HANDLER);\n  METHOD_HANDLER[m.method](game, m);\n}\nfunction send(game, m) {\n  // TODO: sign the message\n  m[\"from\"] = game.userId;\n  p2p.sendData(game.conn, m);\n}\n\nfunction unimplemented() {\n  assert(false, \"not implemented yet!!\");\n}\n\nfunction handleReadyMethod(game, m) {\n  // should be in setup phase\n  if (game.phase !== PHASE.SETUP) return abort(game);\n  // should not have sent start already\n  if (\n    !(\n      game.state === SETUP_STATE.PRE_READY ||\n      game.state === SETUP_STATE.SENT_READY\n    )\n  ) {\n    return abort(game);\n  }\n\n  const user = m.from;\n  const hash = m.hash;\n\n  // shouldn't receive twice; should have different IDs\n  if (game.players.includes(user)) return abort(game);\n\n  game.players.push(user);\n  game.readyHashes[user] = hash;\n\n  // if we have received all, send start\n  maybeSendStart(game);\n\n  update(game);\n}\nasync function handleStartMethod(game, m) {\n  // should be in setup phase\n  if (game.phase !== PHASE.SETUP) return abort(game, \"wrong phase\");\n  // should have sent ready (not necessarily should have sent start though)\n  if (\n    !(\n      game.state === SETUP_STATE.SENT_READY ||\n      game.state === SETUP_STATE.SENT_START\n    )\n  ) {\n    return abort(game);\n  }\n\n  const user = m.from;\n  const randomNumber = m.randomNumber;\n\n  // shouldn't receive twice\n  if (Object.keys(game.startNumbers).includes(user)) return abort(game);\n\n  // should receive from verified user\n  if (!game.players.includes(user)) return abort(game, `unknown user ${user}`);\n\n  // assert that the hash is ok\n  const randomNumberHash = await hash(`${randomNumber}`);\n  if (game.readyHashes[user] !== randomNumberHash)\n    return abort(\n      game,\n      `incorrect hash ${randomNumberHash} received for random number ${randomNumber} from user ${user}`\n    );\n\n  // add to numbers\n  game.startNumbers[user] = randomNumber;\n\n  // if we have received all, go to the game!!\n  maybeStartGame(game);\n\n  update(game);\n}\nfunction handlePlayMethod(game, m) {\n  if (game.phase !== PHASE.PLAY) return abort(game, \"wrong phase\");\n  if (game.state !== PLAY_STATE.WAIT_FOR_PLAY)\n    return abort(game, \"wrong state\");\n\n  const user = m.from;\n  const card = m.card;\n\n  // make sure it is this user's turn\n  if (user !== game.players[game.nextTurn]) {\n    return abort(game, \"user tried to make move but it's not their turn\");\n  }\n\n  // make sure this user owns this card\n  if (!game.playerHands[user].some((c) => c.index === card.index)) {\n    return abort(game, \"user tried to play card not in their hand\");\n  }\n\n  // make sure the card move is legal\n  if (!legalToPlayCard(game, card)) {\n    return abort(game, \"user tried to play illegal card\");\n  }\n\n  // actually do the move\n  actuallyPlayCard(game, user, card);\n\n  sendPlayAck(game, user, card);\n\n  update(game);\n}\nfunction handlePlayAckMethod(game, m) {\n  if (game.phase !== PHASE.PLAY) return abort(game, \"wrong phase\");\n  if (game.state !== PLAY_STATE.WAIT_FOR_PLAYACK)\n    return abort(game, \"wrong state\");\n\n  const user = m.user;\n  const from = m.from;\n  const card = m.card;\n\n  // make sure the right user n right card was acked\n  if (user !== game.lastPlayedUser) {\n    return abort(game, \"tried to ack the wrong user\");\n  }\n  if (card.index !== game.lastPlayedCard.index) {\n    return abort(game, \"tried to ack the wrong card\");\n  }\n\n  if (game.acksReceived.includes(from)) {\n    return abort(game, \"already received ack from this user\");\n  }\n\n  // TODO: verify the zk snarks\n\n  game.acksReceived.push(from);\n\n  maybeStopWaitingForAcks(game);\n\n  update(game);\n}\nfunction handleAbortMethod(game, m) {\n  console.log(\"ABORTING :(((( SAD\");\n  unimplemented();\n\n  update(game);\n}\n\nfunction abort(game, reason) {\n  console.error(\"ABORT GAME :((\");\n  console.error(reason);\n  send(game, { method: METHOD.ABORT, reason });\n  game.phase = PHASE.ABORT;\n\n  update(game);\n}\n\nasync function hash(message) {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(message);\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\n  const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\"); // convert bytes to hex string\n  return hashHex;\n}\n\nfunction actuallyPlayCard(game, user, card) {\n  game.playedCards.push(card);\n  game.playerHands[user] = game.playerHands[user].filter(\n    (c) => c.index !== card.index\n  );\n  game.nextTurn = (game.nextTurn + 1) % game.players.length;\n  game.state = PLAY_STATE.WAIT_FOR_PLAYACK;\n  game.lastPlayedCard = card;\n  game.lastPlayedUser = user;\n  update(game);\n}\n\nfunction legalToPlayCard(game, card) {\n  // first move always legal\n  if (game.playedCards.length === 0) return true;\n  // either suit or rank must be the same\n  const lastCard = game.playedCards[game.playedCards.length - 1];\n  return lastCard.suit === card.suit || lastCard.rank === card.rank;\n}\n\nexport function playCard(game, card) {\n  assert(game.phase === PHASE.PLAY && isMyTurn(game), game);\n  assert(game.state === PLAY_STATE.WAIT_FOR_PLAY, game);\n  assert(\n    game.playerHands[game.userId].some((c) => c.index === card.index),\n    game\n  );\n  console.log(`play card!`);\n  console.log(card);\n\n  assert(legalToPlayCard(game, card), game);\n\n  send(game, { method: METHOD.PLAY, card });\n\n  actuallyPlayCard(game, game.userId, card);\n  update(game);\n}\n\nexport async function sendReady(game) {\n  assert(\n    (game.phase === PHASE.SETUP && game.state === SETUP_STATE.PRE_READY) ||\n      game.phase === PHASE.GAMEOVER,\n    game\n  );\n  // generate a random number\n  game.myRandom = Math.floor(Math.random() * 2 ** 64);\n  // hash the random number\n  const hash_r = await hash(`${game.myRandom}`);\n  console.log(hash_r);\n  game.readyHashes[game.userId] = hash_r;\n  send(game, { method: METHOD.READY, hash: hash_r });\n  game.state = SETUP_STATE.SENT_READY;\n  maybeSendStart(game);\n\n  update(game);\n}\n\nfunction maybeStopWaitingForAcks(game) {\n  // everyone except the player needs to ack the card\n  if (game.acksReceived.length === game.players.length - 1) {\n    game.state = PLAY_STATE.WAIT_FOR_PLAY;\n    game.acksReceived = [];\n    game.lastPlayedCard = null;\n    game.lastPlayedUser = null;\n    update(game);\n  }\n}\n\nfunction sendPlayAck(game, user, card) {\n  assert(\n    game.phase === PHASE.PLAY && game.state === PLAY_STATE.WAIT_FOR_PLAYACK,\n    game\n  );\n\n  // TODO: run the zk rule snarks to determine penalties\n\n  send(game, { method: METHOD.PLAYACK, card, user });\n\n  assert(!game.acksReceived.includes(game.userId), game);\n  game.acksReceived.push(game.userId);\n\n  maybeStopWaitingForAcks(game);\n\n  update(game);\n}\n\nfunction maybeStartGame(game) {\n  if (game.players.length === Object.keys(game.startNumbers).length) {\n    startGame(game);\n  }\n}\nfunction startGame(game) {\n  assert(\n    game.phase === PHASE.SETUP && game.state === SETUP_STATE.SENT_START,\n    game\n  );\n\n  // xor all the random numbers (which means that as long as at least 1 person honest, it is random)\n  let finalRandomNumber = 0;\n  Object.values(game.startNumbers).forEach((randomNumber) => {\n    finalRandomNumber ^= randomNumber;\n  });\n\n  console.log(`final randomness: ${finalRandomNumber}`);\n  // use this random number as the seed of an rng\n  let rng = seedrandom(`${finalRandomNumber}`);\n\n  // now we can transition to the game phase\n  // delete the old game object properties\n  delete game.state;\n  delete game.readyHashes;\n  delete game.startNumbers;\n  delete game.myRandom;\n\n  // shuffle the player list\n  // note: we need to sort it first before we do it so everyone gets the same list\n  game.players = utils.shuffle(game.players.sort(), rng);\n\n  game.nextTurn = 0;\n\n  game.playedCards = []; // start empty\n\n  // now deal cards\n  game.playerHands = cards.dealShuffledCards(\n    utils.shuffle(game.players, rng),\n    rng\n  );\n\n  game.state = PLAY_STATE.WAIT_FOR_PLAY;\n\n  game.acksReceived = [];\n  game.lastPlayedCard = null;\n  game.lastPlayedUser = null;\n\n  // now we're done :))))))\n  game.phase = PHASE.PLAY;\n\n  console.log(\"STARTING GAME!!!! exciting :)))\");\n  console.log(game);\n\n  update(game);\n}\n\nfunction maybeSendStart(game) {\n  if (\n    p2p.numConnections(game.conn) ===\n    Object.keys(game.readyHashes).length - 1\n  ) {\n    assert(game.players.length === Object.keys(game.readyHashes).length, game);\n    sendStart(game);\n  }\n}\nfunction sendStart(game) {\n  assert(\n    game.phase === PHASE.SETUP && game.state === SETUP_STATE.SENT_READY,\n    game\n  );\n\n  send(game, { method: METHOD.START, randomNumber: game.myRandom });\n\n  game.startNumbers[game.userId] = game.myRandom;\n  game.state = SETUP_STATE.SENT_START;\n\n  maybeStartGame(game);\n\n  update(game);\n}\n\n// convenience for 2 players\n// TODO: update this for more players\n\nexport function getMyUserId(game) {\n  return game.userId;\n}\nexport function getOppUserId(game) {\n  return game.players.filter((x) => x !== getMyUserId(game))[0];\n}\nexport function getMyHand(game) {\n  return game.playerHands[getMyUserId(game)];\n}\nexport function getOppHand(game) {\n  return game.playerHands[getOppUserId(game)];\n}\nfunction isMyTurn(game) {\n  return getMyUserId(game) === game.players[game.nextTurn];\n}\nexport function isMyTurnEnabled(game) {\n  return isMyTurn(game) && game.state === PLAY_STATE.WAIT_FOR_PLAY;\n}\n","import React from \"react\";\nimport { useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\n\nexport function Chat(props) {\n  const [chatMessage, setChatMessage] = useState(\"\");\n  const [messages, setMessages] = useState(\"\");\n\n  function onSendMessage() {\n    p2p.sendMessage(props.connRef.current, chatMessage);\n    newMessage(chatMessage);\n    setChatMessage(\"\");\n  }\n\n  function newMessage(m) {\n    setMessages((oldm) => {\n      if (oldm === \"\") return m;\n      return m + \"\\n\" + oldm;\n    });\n  }\n\n  useEffect(() => {\n    const indx = p2p.addMessageHandler(props.connRef.current, (m) => {\n      if (m.type === \"message\") return newMessage(m.message);\n      newMessage(JSON.stringify(m));\n    });\n    return () => {\n      console.log(`cleaning up chat!!! index ${indx}`);\n      p2p.removeMessageHandler(props.connRef.current, indx);\n    };\n  }, [props.connRef]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={chatMessage}\n        onChange={(e) => setChatMessage(e.target.value)}\n        onKeyUp={(e) => (e.key === \"Enter\" ? onSendMessage() : 0)}\n      ></input>\n      <button onClick={onSendMessage}>Send message</button>\n      <p style={{ whiteSpace: \"pre-line\" }}>{messages}</p>\n    </div>\n  );\n}\n","import \"./Game.css\";\nimport React from \"react\";\nimport { useCallback, useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\nimport * as logic from \"./logic.js\";\nimport * as cards from \"./cards.js\";\n\nimport { Chat } from \"./Chat.js\";\n\nfunction Setup() {\n  return <div>Waiting for everyone else to press start...</div>;\n}\n\nfunction Play(props) {\n  const [playedCards, setPlayedCards] = useState(\n    props.gameRef.current.playedCards\n  );\n  const [myHand, setMyHand] = useState(logic.getMyHand(props.gameRef.current));\n  const [oppHand, setOppHand] = useState(\n    logic.getOppHand(props.gameRef.current)\n  );\n  const [myUserId, setMyUserId] = useState(\n    logic.getMyUserId(props.gameRef.current)\n  );\n  const [oppUserId, setOppUserId] = useState(\n    logic.getOppUserId(props.gameRef.current)\n  );\n  const [selectedCard, setSelectedCard] = useState(null);\n  const [myTurn, setMyTurn] = useState(\n    logic.isMyTurnEnabled(props.gameRef.current)\n  );\n  const changeCard = useCallback((e) => {\n    setSelectedCard(e.currentTarget.value);\n  }, []);\n\n  const updateGameState = useCallback(() => {\n    setPlayedCards(props.gameRef.current.playedCards);\n    setMyHand(logic.getMyHand(props.gameRef.current));\n    setOppHand(logic.getOppHand(props.gameRef.current));\n    setMyUserId(logic.getMyUserId(props.gameRef.current));\n    setOppUserId(logic.getOppUserId(props.gameRef.current));\n    setMyTurn(logic.isMyTurnEnabled(props.gameRef.current));\n  }, [props.gameRef]);\n\n  useEffect(() => {\n    const indx = logic.addListener(props.gameRef.current, updateGameState);\n    return () => {\n      logic.removeListener(props.gameRef.current, indx);\n    };\n  }, [props.gameRef, updateGameState]);\n\n  return (\n    <div>\n      Playing the game!!!\n      <hr />\n      <Hand cards={oppHand} user={oppUserId} />\n      <PlayedCards cards={playedCards} />\n      <MyHand\n        cards={myHand}\n        user={myUserId}\n        changeCard={changeCard}\n        selectedCard={selectedCard}\n      />\n      <PlayButton\n        myTurn={myTurn}\n        play={() =>\n          logic.playCard(\n            props.gameRef.current,\n            cards.deserializeCard(selectedCard)\n          )\n        }\n      />\n    </div>\n  );\n}\n\nfunction PlayButton(props) {\n  return (\n    <div>\n      <button onClick={props.play} disabled={!props.myTurn}>\n        Play!\n      </button>\n    </div>\n  );\n}\n\nfunction PlayedCards(props) {\n  return (\n    <div>\n      played cards: <Deck cards={props.cards} />\n    </div>\n  );\n}\n\nfunction Hand(props) {\n  return (\n    <div>\n      {props.user}'s cards:\n      <Deck cards={props.cards} />\n    </div>\n  );\n}\nfunction MyHand(props) {\n  return (\n    <div>\n      my cards:\n      <SelectableDeck\n        cards={props.cards}\n        changeCard={props.changeCard}\n        selectedCard={props.selectedCard}\n      />\n    </div>\n  );\n}\nfunction Deck(props) {\n  if (props.cards.length === 0) {\n    return <div>(none)</div>;\n  }\n  return (\n    <div style={{ fontSize: \"3em\" }}>{cards.serializeDeck(props.cards)}</div>\n  );\n}\nfunction SelectableDeck(props) {\n  if (props.cards.length === 0) {\n    return <div>(none)</div>;\n  }\n  return (\n    <div style={{ fontSize: \"3em\" }} className=\"SelectableDeck\">\n      {props.cards.map((card, index) => {\n        return (\n          <React.Fragment key={`mycardsfragment${index}`}>\n            <input\n              type=\"radio\"\n              name=\"mycards\"\n              value={cards.serializeCard(card)}\n              checked={props.selectedCard === cards.serializeCard(card)}\n              onChange={props.changeCard}\n              id={cards.serializeCardASCII(card)}\n              key={`mycardsradio${index}`}\n            />\n            <label\n              htmlFor={cards.serializeCardASCII(card)}\n              key={`mycardslabel${index}`}\n            >\n              {cards.serializeCard(card)}\n            </label>\n          </React.Fragment>\n        );\n      })}\n    </div>\n  );\n}\n\nexport function Game(props) {\n  const [phase, setPhase] = useState(props.gameRef.current.phase);\n  const [myUserId, setMyUserId] = useState(\n    logic.getMyUserId(props.gameRef.current)\n  );\n\n  const updateGameState = useCallback(() => {\n    setPhase(props.gameRef.current.phase);\n    setMyUserId(logic.getMyUserId(props.gameRef.current));\n  }, [props.gameRef]);\n\n  useEffect(() => {\n    const indx = logic.addListener(props.gameRef.current, updateGameState);\n    return () => {\n      logic.removeListener(props.gameRef.current, indx);\n    };\n  }, [props.gameRef, updateGameState]);\n\n  return (\n    <div>\n      welcome to the game, {myUserId}!\n      <hr />\n      {phase === logic.PHASE.SETUP && <Setup />}\n      {phase === logic.PHASE.PLAY && <Play gameRef={props.gameRef} />}\n      <hr />\n      <Chat connRef={props.connRef} />\n    </div>\n  );\n}\n","import \"./App.css\";\nimport React from \"react\";\nimport { useCallback, useRef, useEffect, useState } from \"react\";\nimport * as p2p from \"./p2p.js\";\nimport * as logic from \"./logic.js\";\n\nimport { Game } from \"./Game.js\";\nimport { Chat } from \"./Chat.js\";\n\nfunction Create1(props) {\n  return (\n    <div>\n      <button\n        onClick={() => p2p.createOffer(props.connRef.current, props.setMyOffer)}\n      >\n        Create game\n      </button>\n    </div>\n  );\n}\n\nfunction Create2(props) {\n  const [joinKey, setJoinKey] = useState(\"\");\n  return (\n    <div>\n      send this message to your friends: <code>{props.offer}</code>\n      <br />\n      input their answer:\n      <input\n        type=\"text\"\n        value={joinKey}\n        onChange={(e) => setJoinKey(e.target.value)}\n      ></input>\n      <button onClick={() => p2p.acceptAnswer(props.connRef.current, joinKey)}>\n        Add player\n      </button>\n    </div>\n  );\n}\n\nfunction Join1(props) {\n  const [joinKey, setJoinKey] = useState(\"\");\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={joinKey}\n        onChange={(e) => setJoinKey(e.target.value)}\n      ></input>\n      <button\n        onClick={() =>\n          p2p.join(props.connRef.current, joinKey, props.setMyAnswer)\n        }\n      >\n        Join\n      </button>\n    </div>\n  );\n}\n\nfunction Join2(props) {\n  return (\n    <div>\n      send this message to your friends: <code>{props.answer}</code>\n      <br />\n    </div>\n  );\n}\n\nfunction Welcome(props) {\n  console.log(props.connRef);\n  return (\n    <div>\n      <Create1 connRef={props.connRef} setMyOffer={props.setMyOffer} />\n      <br />\n      <Join1 connRef={props.connRef} setMyAnswer={props.setMyAnswer} />\n      <br />\n    </div>\n  );\n}\n\nfunction Lobby(props) {\n  return (\n    <div>\n      {props.offer ? (\n        <Create2 connRef={props.connRef} offer={props.offer} />\n      ) : (\n        <Join2 connRef={props.connRef} answer={props.answer} />\n      )}\n      <hr />\n      Participants list: idk\n      <br />\n      <hr />\n      <button onClick={props.startGame}>Start game!</button>\n      <hr />\n      <Chat connRef={props.connRef} />\n    </div>\n  );\n}\n\nfunction Setup(props) {\n  const [myOffer, setMyOffer] = useState(null);\n  const [myAnswer, setMyAnswer] = useState(null);\n\n  if (myOffer || myAnswer) {\n    return (\n      <Lobby\n        connRef={props.connRef}\n        offer={myOffer}\n        answer={myAnswer}\n        startGame={props.startGame}\n      />\n    );\n  } else {\n    return (\n      <React.Fragment>\n        <Welcome\n          connRef={props.connRef}\n          setMyOffer={setMyOffer}\n          setMyAnswer={setMyAnswer}\n        />\n      </React.Fragment>\n    );\n  }\n}\n\nfunction App() {\n  const [inSetup, setInSetup] = useState(true);\n  const connRef = useRef();\n  const gameRef = useRef();\n\n  const startGame = useCallback(() => {\n    setInSetup(false);\n    logic.sendReady(gameRef.current);\n  }, [gameRef]);\n\n  useEffect(() => {\n    connRef.current = p2p.createConn();\n    gameRef.current = logic.createGame(connRef.current);\n  }, []);\n\n  useEffect(() => {\n    const indx = p2p.addMessageHandler(connRef.current, (m) =>\n      logic.receive(gameRef.current, m)\n    );\n    return () => {\n      p2p.removeMessageHandler(connRef.current, indx);\n    };\n  }, [connRef, gameRef]);\n\n  return (\n    <div className=\"App\">\n      {inSetup && <Setup connRef={connRef} startGame={startGame} />}\n      {!inSetup && <Game connRef={connRef} gameRef={gameRef} />}\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}